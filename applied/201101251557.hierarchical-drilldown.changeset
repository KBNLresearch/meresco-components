Changeset created on Tue Jan 25 15:57:52 CET 2011 by Seek You Too

Description: Added an hierarchical drilldown

     The hierarchical drilldown can be used besides the normal drilldown. The hierarchicaldrilldown needs a list with the nested drilldown fields. It returns a nested dictionary with fieldnames and terms and for every term the name, count and extra the nested drilldown.

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-components/workingsets/3.4.6-MWE/version_0

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/components/facetindex/drilldownfieldnames.py version_1/meresco/components/facetindex/drilldownfieldnames.py
--- version_0/meresco/components/facetindex/drilldownfieldnames.py	2011-01-20 14:45:45.000000000 +0100
+++ version_1/meresco/components/facetindex/drilldownfieldnames.py	2011-01-25 15:57:37.000000000 +0100
@@ -48,4 +48,28 @@
                 for field, termCounts in drilldownResults]
         except NoFacetIndexException, e:
             raise NoFacetIndexException(reverseLookup[e.field], e.fields)
-            
+           
+
+    def hierarchicalDrilldown(self, docset, fieldsAndMaximums):
+        reverseLookup = {}
+        translatedFields = []
+        for fields, maximum, sort in fieldsAndMaximums:
+            newFields = []
+            for field in fields:
+                translated = self.lookup(field)
+                reverseLookup[translated] = field
+                newFields.append(translated)
+            translatedFields.append((newFields, maximum, sort))
+        drilldownResults = self.any.hierarchicalDrilldown(docset, translatedFields)
+
+        def translateField(remainderGenerator):
+            for field in remainderGenerator:
+                yield dict(
+                    fieldname=reverseLookup[field['fieldname']], 
+                    terms=(dict(
+                        term=item['term'], 
+                        count=item['count'], 
+                        remainder=translateField(item['remainder'])) for item in field['terms']))
+
+        return translateField(drilldownResults)
+        #return [dict(fieldname=reverseLookup[fields['fieldname']], terms=fields['terms']) for fields in drilldownResults]
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/components/facetindex/drilldown.py version_1/meresco/components/facetindex/drilldown.py
--- version_0/meresco/components/facetindex/drilldown.py	2011-01-20 14:45:45.000000000 +0100
+++ version_1/meresco/components/facetindex/drilldown.py	2011-01-25 15:57:37.000000000 +0100
@@ -28,7 +28,9 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
-from .docsetlist import DocSetList, JACCARD_MI
+
+from docset import DocSet
+from docsetlist import DocSetList, JACCARD_MI
 from merescolucene import Term, IndexReader, iterJ  
 from time import time
 from sys import maxint
@@ -49,11 +51,10 @@
 class Drilldown(object):
 
     def __init__(self, drilldownFields=None, transactionName=None):
-        drilldownFields = drilldownFields or ['*']
         self._drilldownFields = []
         self._prefixes = []
         self._compoundFields = []
-        for field in drilldownFields:
+        for field in drilldownFields if drilldownFields else []:
             if type(field) == tuple:
                 self._compoundFields.append(field)
             elif field.endswith('*'):
@@ -75,6 +76,8 @@
             self._docsetlists[compoundField].addDocument(docId, terms)
 
     def _isDrilldownField(self, field):
+        if type(field) == tuple and field in self._compoundFields:
+            return True
         if field.startswith('__'):
             return False
         if field in self._drilldownFields:
@@ -142,14 +145,42 @@
         return self._docsetlists.keys()
 
     def drilldown(self, docset, drilldownFieldnamesAndMaximumResults=None, defaultMaximumResults=0, defaultSorting=False):
-        allActualFields = self._docsetlists.keys()
         if not drilldownFieldnamesAndMaximumResults:
-            drilldownFieldnamesAndMaximumResults = [(fieldname, defaultMaximumResults, defaultSorting)
-                for fieldname in allActualFields]
-        for fieldname, maximumResults, sorted in drilldownFieldnamesAndMaximumResults:
-            if fieldname not in allActualFields:
-                raise NoFacetIndexException(fieldname, allActualFields)
-            yield fieldname, self._docsetlists[fieldname].termCardinalities(docset, maximumResults or maxint, sorted)
+            drilldownFieldnamesAndMaximumResults = [
+                (fieldname, defaultMaximumResults, defaultSorting)
+                for fieldname in self._docsetlists]
+        for fieldname, maximumResults, howToSort in drilldownFieldnamesAndMaximumResults:
+            if not self._isDrilldownField(fieldname):
+                raise NoFacetIndexException(fieldname, self.listFields())
+
+            docsetlist = self._docsetlists[fieldname]
+            yield fieldname, docsetlist.termCardinalities(docset, maximumResults or maxint, howToSort)
+
+    def hierarchicalDrilldown(self, docset, drilldownFieldnamesAndMaximumResults=None, defaultMaximumResults=0, defaultSorting=False):
+        if not drilldownFieldnamesAndMaximumResults:
+            drilldownFieldnamesAndMaximumResults = [
+                (fieldname, defaultMaximumResults, defaultSorting)
+                for fieldname in self._docsetlists]
+        for fieldname, maximumResults, howToSort in drilldownFieldnamesAndMaximumResults:
+            if fieldname == []:
+                raise StopIteration()
+            fieldname, remainingFields = fieldname[0], fieldname[1:]
+
+            if not self._isDrilldownField(fieldname):
+                raise NoFacetIndexException(fieldname, self.listFields())
+
+            docsetlist = self._docsetlists[fieldname]
+            termCardinalities = docsetlist.termCardinalities(docset, maximumResults or maxint, howToSort)
+            yield dict(fieldname=fieldname, terms=self._buildHierarchicalDrilldownTree(
+                        docset, docsetlist, termCardinalities, 
+                        [(remainingFields, maximumResults, howToSort)]))
+
+    def _buildHierarchicalDrilldownTree(self, docset, docsetlist, termCardinalities, drilldownFieldnamesAndMaximumResults):
+        #intersectedDocsetlist = docsetlist.intersect(docset)
+        for term, cardinality in termCardinalities:
+            docsetForTerm = docsetlist._TEST_getDocsetForTerm(term)
+            intersectedTermDocset = DocSet(sorted(docsetForTerm.intersect(docset)))
+            yield dict(term=term, count=cardinality, remainder=self.hierarchicalDrilldown(intersectedTermDocset, drilldownFieldnamesAndMaximumResults))
 
     def jaccard(self, docset, jaccardFieldsAndRanges, algorithm=JACCARD_MI, maxTermFreqPercentage=100):
         for fieldname, minimum, maximum in jaccardFieldsAndRanges:
Only in version_0/test: drilldown
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/facetindex/docsettest.py version_1/test/facetindex/docsettest.py
--- version_0/test/facetindex/docsettest.py	2011-01-20 14:45:44.000000000 +0100
+++ version_1/test/facetindex/docsettest.py	2011-01-25 15:57:37.000000000 +0100
@@ -92,13 +92,21 @@
         except Exception, e:
             self.assertTrue('non-increasing' in str(e))
 
-    def assertIntersect(self, lhs, rhs):
+    def XXXX_assertIntersect(self, lhs, rhs):
         soll = set(lhs).intersection(set(rhs))
         intersection1 = DocSet(lhs).intersect(DocSet(rhs))
         ist1 = set(iter(intersection1))
         ist2 = set(iter(DocSet(rhs).intersect(DocSet(lhs))))
         self.assertEquals(soll, ist1)
         self.assertEquals(soll, ist2)
+    
+    def assertIntersect(self, lhs, rhs):
+        soll = sorted(set(lhs).intersection(set(rhs)))
+        intersection1 = DocSet(lhs).intersect(DocSet(rhs))
+        ist1 = list(iter(intersection1))
+        ist2 = list(iter(DocSet(rhs).intersect(DocSet(lhs))))
+        self.assertEquals(soll, ist1)
+        self.assertEquals(soll, ist2)
 
     def testIntersect(self):
         self.assertIntersect([], [])
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/facetindex/drilldownfieldnamestest.py version_1/test/facetindex/drilldownfieldnamestest.py
--- version_0/test/facetindex/drilldownfieldnamestest.py	2011-01-20 14:45:44.000000000 +0100
+++ version_1/test/facetindex/drilldownfieldnamestest.py	2011-01-25 15:57:37.000000000 +0100
@@ -30,6 +30,7 @@
 from cq2utils import CQ2TestCase, CallTrace
 from meresco.components.facetindex import DrilldownFieldnames
 from meresco.components.facetindex.drilldown import NoFacetIndexException
+from testutils import generators2lists
 
 class DrilldownFieldnamesTest(CQ2TestCase):
 
@@ -46,6 +47,33 @@
 
         self.assertEquals([('field1', [('term1',1)]),('field2', [('term2', 2)])], result)
 
+    def testHierarchicalDrilldown(self):
+        d = DrilldownFieldnames(lookup=lambda name: 'drilldown.'+name)
+        observer = CallTrace('drilldown')
+        observer.returnValues['hierarchicalDrilldown'] = [
+            dict(fieldname="drilldown.field1", terms=(term for term in [
+                dict(term="term1", count=1, remainder=(field for field in [
+                    dict(fieldname="drilldown.field2", terms=(term for term in [
+                        dict(term="term2", count=2, remainder=(x for x in []))])
+                    )])
+                )])
+            )]
+                    
+        d.addObserver(observer)
+
+        result = generators2lists(d.hierarchicalDrilldown('docset', [(['field1', 'field2'], 0, True)]))
+
+        self.assertEquals(1, len(observer.calledMethods))
+        self.assertEquals([(['drilldown.field1', 'drilldown.field2'], 0, True)], list(observer.calledMethods[0].args[1]))
+
+        self.assertEquals([
+            {'fieldname': 'field1', 'terms': 
+                [{'count': 1, 'term': 'term1', 'remainder': 
+                    [{'fieldname': 'field2', 'terms': 
+                        [{'count': 2, 'term': 'term2', 'remainder': []}]
+                    }]
+                }]
+            }], result)
 
     def testReverseLookupInException(self):
         d = DrilldownFieldnames(lookup=lambda name: 'drilldown.'+name)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/facetindex/drilldowntest.py version_1/test/facetindex/drilldowntest.py
--- version_0/test/facetindex/drilldowntest.py	2011-01-20 14:45:44.000000000 +0100
+++ version_1/test/facetindex/drilldowntest.py	2011-01-25 15:57:37.000000000 +0100
@@ -28,11 +28,12 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
-from struct import calcsize
-from meresco.components.facetindex.merescolucene import Term, TermQuery, IndexReader, MatchAllDocsQuery
 
+from struct import calcsize
+from testutils import generators2lists
 from cq2utils import CQ2TestCase, CallTrace
 
+from meresco.components.facetindex.merescolucene import Term, TermQuery, IndexReader, MatchAllDocsQuery
 from meresco.components.facetindex.document import Document
 from meresco.components.facetindex.drilldown import Drilldown, NoFacetIndexException
 from meresco.components.facetindex.lucene import LuceneIndex
@@ -104,6 +105,38 @@
         self.assertEquals(set([("this is term_0", 1), ("this is term_1", 2)]), set(result['field_0']))
         self.assertEquals([("inquery", 3)], list(result['field_1']))
 
+    def testHierarchicalDrilldown(self):
+        self.createDrilldown(['faculty', 'group'])
+        self.addUntokenized([
+            ('0', {'faculty': 'economie',    'group': 'accounting'}),
+            ('1', {'faculty': 'geneeskunde', 'group': 'cardiologie'}),
+            ('2', {'faculty': 'geneeskunde', 'group': 'cardiologie'}),
+            ('3', {'faculty': 'geneeskunde', 'group': 'biochemie'}),
+            ('4', {'faculty': 'economie',    'group': 'algemeen'}),
+            ('5', {'faculty': 'economie',    'group': 'accounting'}),
+            ('6', {'faculty': 'geneeskunde', 'group': 'algemeen'}),
+            ('7', {'faculty': 'wiskunde',    'group': 'algemeen'}),
+        ])
+        queryDocset = self.index.docsetFromQuery(MatchAllDocsQuery())
+        drilldownResults = self.drilldown.hierarchicalDrilldown(queryDocset, [(['faculty', 'group'], 2, False)])
+
+        self.assertEquals([
+            dict(fieldname='faculty', terms=[
+                dict(term='economie', count=3, remainder=[
+                    dict(fieldname='group', terms=[
+                        dict(term='accounting', count=2, remainder=[]),
+                        dict(term='algemeen',   count=1, remainder=[])
+                    ])
+                 ]),
+                 dict(term='geneeskunde', count=4, remainder=[
+                    dict(fieldname='group', terms=[
+                        dict(term='algemeen', count=1, remainder=[]),
+                        dict(term='biochemie', count=1, remainder=[]),
+                    ])
+                 ])
+             ])
+        ], generators2lists(drilldownResults))
+
     def testSortingOnCardinality(self):
         self.createDrilldown(['field0'])
         self.addUntokenized([
@@ -210,6 +243,19 @@
         except NoFacetIndexException, e:
             self.assertEquals("No facetindex for field 'name'. Available fields: 'title'", str(e))
 
+    def testIsDrilldownField(self):
+        drilldown = Drilldown()
+        self.assertFalse(drilldown._isDrilldownField("thingy"))
+        drilldown = Drilldown(drilldownFields=['*'])
+        self.assertTrue(drilldown._isDrilldownField("thingy"))
+        self.assertFalse(drilldown._isDrilldownField("__thingy"))
+        drilldown = Drilldown(drilldownFields=['thing*'])
+        self.assertTrue(drilldown._isDrilldownField("thingy"))
+        drilldown = Drilldown(drilldownFields=['thingy'])
+        self.assertTrue(drilldown._isDrilldownField("thingy"))
+        drilldown = Drilldown(drilldownFields=[('thingy', )])
+        self.assertTrue(drilldown._isDrilldownField(("thingy",)))
+
     def testAddDocument(self):
         drilldown = Drilldown(['title'])
         self.assertEquals(0, drilldown.queueLength())
@@ -310,7 +356,7 @@
         dsl0 = drilldown.intersect('field_0', DocSet([0,1,2,3]))
         self.assertEquals([[0], [1,2], [3]], list(dsl0))
         dsl1 = drilldown.intersect('field_1', DocSet([0,1,2,3]))
-        self.assertEquals([[0,2,1],[3]], list(dsl1))
+        self.assertEquals([[0,1,2],[3]], list(dsl1))
 
     def testMultiFieldDrilldown(self):
         drilldown = Drilldown(['field_0', ('keyword', 'title'), 'field_1'])
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/facetindex/testutils.py version_1/test/facetindex/testutils.py
--- version_0/test/facetindex/testutils.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/facetindex/testutils.py	2011-01-25 15:57:37.000000000 +0100
@@ -0,0 +1,34 @@
+## begin license ##
+#
+#    Meresco Components are components to build searchengines, repositories
+#    and archives, based on Meresco Core.
+#    Copyright (C) 2011 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2011 Maastricht University http://www.um.nl
+#
+#    This file is part of Meresco Components.
+#
+#    Meresco Components is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Components is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Components; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from types import ListType, GeneratorType, DictType
+
+def generators2lists(o): 
+    t = type(o)
+    if t in [ListType, GeneratorType]:
+        o = [generators2lists(element) for element in o]
+    if t is DictType:
+        o = dict((key, generators2lists(value)) for key, value in o.items())
+    return o
+
