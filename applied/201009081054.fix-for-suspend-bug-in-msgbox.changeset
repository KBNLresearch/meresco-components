Changeset created on Wed Sep  8 10:54:47 CEST 2010 by Seek You Too

Description: Fix for suspend bug in Msgbox 

    Two concurrent request to the Msgbox can cause the suspend object to be used twice for different request. That results in a suspende directorywatcher which is never resumed. After this, the msgbox will not handle any more request and must be restarted. Now the suspend object is not known to the msgbox anymore, when it's used and therefore it cannot be used by another request at 'mostly' the same time.

Baseline version: meresco-components/workingsets/3.1.3-Edurep-Bugfix/version_0

diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/meresco/components/msgbox/msgbox.py version_1/meresco/components/msgbox/msgbox.py
--- version_0/meresco/components/msgbox/msgbox.py	2010-09-03 22:17:22.000000000 +0200
+++ version_1/meresco/components/msgbox/msgbox.py	2010-09-08 10:51:14.000000000 +0200
@@ -28,7 +28,7 @@
 from os.path import join, isdir, isfile, basename, abspath
 from os import rename, listdir, remove, makedirs, link
 from shutil import rmtree
-from traceback import format_exc
+from traceback import format_exc, print_exc
 from sys import stderr
 
 from meresco.core import Observable
@@ -111,21 +111,29 @@
         if ackOrError:
             basename, extension = filename.rsplit('.', 1)
             identifier = unescapeFilename(basename)
-            suspend = self._suspended.get(identifier, None)
-        try:
-            if suspend is None:
-                identifier = unescapeFilename(filename)
+            suspend = self._suspended.pop(identifier, None)
+            
+        if suspend is None:
+            identifier = unescapeFilename(filename)
+            try:
                 self.do.add(identifier=identifier, filedata=File(filepath)) # asyncdo !!
                 if self._synchronous and not ackOrError:
                     self._ack(filename)
-            elif extension == 'error':
-                suspend.throw(Exception(open(filepath).read()))
-            else:
-                suspend.resume()
-        except Exception:
-            self._logError(format_exc())
-            if not ackOrError:
-                self._error(filename, format_exc())
+            except (IOError, ValueError), e: #Java errors, like not valid RDF, must be ValueErrors and should be handled here.
+                if type(e) == IOError and e.errno != 2:
+                    print_exc()
+                if not ackOrError:
+                    self._error(filename, format_exc())
+            except Exception: #All other exceptions should raise an error in the reactor. (When java errors are not Exceptions anymore)
+                print_exc()
+                if not ackOrError:
+                    self._error(filename, format_exc())
+
+        elif extension == 'error':
+            suspend.throw(Exception(open(filepath).read()))
+        else:
+            suspend.resume()
+        
         self._forgivingRemove(filepath)
 
     def _ack(self, filename):
@@ -137,18 +145,18 @@
     def _isAckOrError(self, filename):
         return filename.endswith('.ack') or filename.endswith('.error')
 
-    def _logError(self, errorMessage):
-        stderr.write(errorMessage)
-        stderr.flush()
-
     def add(self, identifier, filedata, **kwargs):
         filename = escapeFilename(identifier)
         self._add(filename, filedata, **kwargs)
         if self._asynchronous:
+            if identifier in self._suspended:
+                duplicateError = ValueError("Concurrent request for identical identifiers on Msgbox")
+                self._suspended[identifier].throw(duplicateError)
+                del self._suspended[identifier]
+                raise duplicateError
             suspend = Suspend()
             self._suspended[identifier] = suspend
             yield suspend
-            del self._suspended[identifier]
             suspend.getResult()
 
     def _add(self, filename, filedata, **kwargs):
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/meresco/components/msgbox/updateadapter.py version_1/meresco/components/msgbox/updateadapter.py
--- version_0/meresco/components/msgbox/updateadapter.py	2010-09-03 22:17:22.000000000 +0200
+++ version_1/meresco/components/msgbox/updateadapter.py	2010-09-08 10:51:14.000000000 +0200
@@ -37,7 +37,7 @@
         elif extension == "add":
             self.do.add(identifier, '', filedata)
         else:
-            raise Exception('Expected add or delete as file extension')
+            raise ValueError('Expected add or delete as file extension')
 
 class UpdateAdapterToMsgbox(Observable):
 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/msgbox/msgboxtest.py version_1/test/msgbox/msgboxtest.py
--- version_0/test/msgbox/msgboxtest.py	2010-09-03 22:17:19.000000000 +0200
+++ version_1/test/msgbox/msgboxtest.py	2010-09-08 10:51:14.000000000 +0200
@@ -35,6 +35,9 @@
 from lxml.etree import tostring
 from shutil import rmtree
 from stat import S_IXUSR, S_IRUSR, S_IWUSR
+from time import sleep
+
+from threading import Thread
 
 from meresco.components.msgbox import Msgbox
 from meresco.components.msgbox.msgbox import File
@@ -43,7 +46,7 @@
 DATA = "<record/>"
 
 def failingAddMock(identifier=None, filedata=None):
-    result = 1/0
+    raise ValueError()
 
 class MsgboxTest(CQ2TestCase):
 
@@ -114,7 +117,7 @@
         self.assertTrue(isfile(errorFile))
         errorMessage = open(errorFile).read()
         self.assertTrue(errorMessage.startswith("Traceback (most recent call last):"))
-        self.assertTrue(errorMessage.endswith("ZeroDivisionError: integer division or modulo by zero\n"), errorMessage)
+        self.assertTrue(errorMessage.endswith("ValueError\n"), errorMessage)
 
     def testErrorHandlingWithReactorStep(self):
         self.observer.add = failingAddMock
@@ -129,7 +132,7 @@
         self.assertTrue(isfile(errorFile))
         errorMessage = open(errorFile).read()
         self.assertTrue(errorMessage.startswith("Traceback (most recent call last):"))
-        self.assertTrue(errorMessage.endswith("ZeroDivisionError: integer division or modulo by zero\n"), errorMessage)
+        self.assertTrue(errorMessage.endswith("ValueError\n"), errorMessage)
         self.assertTrue(self.msgbox._watcher in self.reactor._readers)
 
     def testCreateAsynchronousMsgbox(self):
@@ -163,7 +166,7 @@
         self.assertTrue(isfile(errorFile))
         errorMessage = open(errorFile).read()
         self.assertTrue(errorMessage.startswith("Traceback (most recent call last):"))
-        self.assertTrue(errorMessage.endswith("ZeroDivisionError: integer division or modulo by zero\n"), errorMessage)
+        self.assertTrue(errorMessage.endswith("ValueError\n"), errorMessage)
         self.assertTrue(self.msgbox._watcher in self.reactor._readers)
     
     def testAck(self):
@@ -289,6 +292,19 @@
         self.assertRaises(StopIteration, result.next)
         self.assertTrue(isfile(join(self.outDirectory, 'filename')))
 
+    def testSecondAddWhenFirstIsSuspended(self):
+        self.createMsgbox(asynchronous=True)
+        myreactor = CallTrace('reactor')
+        myreactor.returnValues['suspend'] = 'handle'
+
+        result = self.msgbox.add('filename', 'data')
+        suspend = result.next()
+        suspend(myreactor, lambda: None)
+
+        self.assertRaises(ValueError, self.msgbox.add('filename', 'data').next)
+        self.assertRaises(ValueError, result.next)
+        self.assertFalse('filename' in self.msgbox._suspended)
+
     def testAddAsynchronousYieldsSuspendAndReceivesAck(self):
         self.createMsgbox(asynchronous=True)
         myreactor = CallTrace('reactor')
@@ -305,7 +321,9 @@
         self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
        
         self.moveInRecord('filename.ack', '')
+        self.assertTrue('filename' in self.msgbox._suspended)
         self.reactor.step()
+        self.assertFalse('filename' in self.msgbox._suspended)
 
         self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
 
@@ -392,8 +410,51 @@
         self.assertEquals('add', calledMethod.name)
         self.assertEquals(identifier + '.error', calledMethod.kwargs['identifier'])
 
+    def testOverwrittenInsertInProcessFile(self):
+        self.createMsgbox()
+        mockAddTrigger = []
+        errorRaised = []
+        ackCalled = []
+        errorCalled = []
+        def mockAdd(*args, **kwargs):
+            mockAddTrigger.append(1)
+            while len(mockAddTrigger) < 2:
+                sleep(0.01)
+            # Will crash the 2nd time ...
+            try:
+                open(join(self.inDirectory, filename)).close()
+            except:
+                errorRaised.append(1)
+                raise
+        def mockAck(*args, **kwargs):
+            ackCalled.append(1)
+        def mockError(*args, **kwargs):
+            errorCalled.append(1)
+        self.observer.methods["add"] = mockAdd
+        self.msgbox._error = mockError
+        self.msgbox._ack = mockAck
+        filename = 'dejavu.txt'
+        filedata = "something"
+        
+        reactorThread = Thread(None, self.doubleStepper, "reactor")
+        reactorThread.start()
+        
+        # Move in first record, wait until in add call (mockAdd)
+        self.moveInRecord(filename)
+        while len(mockAddTrigger) < 1:
+            sleep(0.01)
+        self.moveInRecord(filename)
+        # Moved in second file, first step can continue (That step may not remove the input file, because it's overwritten by the second move in)
+        mockAddTrigger.append(2)
+        reactorThread.join()
+        self.assertEquals(1, len(errorRaised))
+        self.assertEquals(1, len(ackCalled))
+        self.assertEquals(1, len(errorCalled))
 
     # helper methods
+    def doubleStepper(self):
+        self.reactor.step()
+        self.reactor.step()
 
     def createMsgbox(self, asynchronous=False):
         self.msgbox = Msgbox(self.reactor, inDirectory=self.inDirectory, outDirectory=self.outDirectory, asynchronous=asynchronous)
