Changeset created on Tue Sep 21 13:22:39 UTC 2010 by Seek You Too

Description: Add waits while file present in out directory + cleanups

    Writing file to outDirectory is suspended as long as that file already exists. '_purge' and '_forgivingRemove' were no longer necessary and therefore removed. Exception handling simplified.

Impact: internal cleanup only.

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-components/workingsets/3.1.5-Edurep/version_7

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_7/meresco/components/msgbox/msgbox.py version_7-cleanupMsgbox/meresco/components/msgbox/msgbox.py
--- version_7/meresco/components/msgbox/msgbox.py	2010-09-21 07:02:41.000000000 +0000
+++ version_7-cleanupMsgbox/meresco/components/msgbox/msgbox.py	2010-09-21 13:21:18.000000000 +0000
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 ## begin license ##
 #
 #    Meresco Components are components to build searchengines, repositories
@@ -30,31 +31,34 @@
 from shutil import rmtree
 from traceback import format_exc, print_exc
 from sys import stderr
+from random import randint
+from tempfile import NamedTemporaryFile
 
 from meresco.core import Observable
 from cq2utils import DirectoryWatcher
 from weightless import Suspend
 from escaping import escapeFilename, unescapeFilename
 
+
 class Msgbox(Observable):
     """
-    Msgbox provides a file based messaging protocol: it receives incoming files and 
+    Msgbox provides a file based messaging protocol: it receives incoming files and
     supports a standardized mechanism for sending files.
 
     Msgbox monitors its inDirectory for files being moved into it. Each moved in file is
-    read and passed on to the observers of Msgbox using self.do.add(filepath=filepath). 
+    read and passed on to the observers of Msgbox using self.do.add(filepath=filepath).
     By default a Msgbox writes an acknowledgment (.ack) file to its outDirectory as
-    soon as the 'add' call returns. When an exception was raised an error (.error) 
+    soon as the 'add' call returns. When an exception was raised an error (.error)
     file is written instead, which contains the full traceback for the error.
-    
+
     To send a file, the Msgbox.add(filename, filedata) method can be used. It writes
-    the filedata to the file in a temporary directory and then moves it into the 
+    the filedata to the file in a temporary directory and then moves it into the
     outDirectory. Notice that this allows for another Msgbox instance to receive the
     file.
 
     An asynchronous Msgbox differs from the default synchronous Msgbox in that it doesn't
-    write the .ack file when the self.do.add call returns. Rather, an explicit 
-    acknowledgement (or error notification) is expected in the form of a request to 
+    write the .ack file when the self.do.add call returns. Rather, an explicit
+    acknowledgement (or error notification) is expected in the form of a request to
     send an acknowledgement (or error) file (by way of the previously
     described Msgbox.add method).
 
@@ -63,13 +67,13 @@
     The Msgbox intentionally only listens to move events. This avoids reading
     partial files that are still being written to. The move operation is atomic
     and makes sure that the events of putting something into the Msgbox and
-    reading it are serialized. NOTE: move files into the Msgbox's inDirectory 
+    reading it are serialized. NOTE: move files into the Msgbox's inDirectory
     only from the same file system to keep its atomicity property.
 
     When the system starts up, the Msgbox does not generate events for files that
     are already in the inDirectory. This avoids uncontrolled bursts.
     Instead, when there are still files in the inDirectory when the system is
-    restarted, either move them out and back in again or use the method 
+    restarted, either move them out and back in again or use the method
     processInDirectory() to generate events for existing files programmatically.
     """
 
@@ -113,96 +117,88 @@
             basename, extension = filename.rsplit('.', 1)
             identifier = unescapeFilename(basename)
             suspend = self._suspended.pop(identifier, None)
-            
-        if suspend is None:
+        if not suspend is None:
+            if extension == 'error':
+                suspend.throw(Exception(open(filepath).read()))
+            else:
+                suspend.resume()
+        else:
             identifier = unescapeFilename(filename)
             try:
                 self.do.add(identifier=identifier, filedata=File(filepath))
                 needToAck = self._synchronous and not ackOrError
-            except (IOError, ValueError), e: #Java errors, like not valid RDF, must be ValueErrors and should be handled here.
-                if type(e) == IOError and e.errno != 2:
+            except Exception, e:
+                if not self._impliesInputError(e):
                     print_exc()
                 if not ackOrError:
                     self._error(filename, format_exc())
-            except Exception: #All other exceptions should raise an error in the reactor. (When java errors are not Exceptions anymore)
-                print_exc()
-                if not ackOrError:
-                    self._error(filename, format_exc())
-
-        elif extension == 'error':
-            suspend.throw(Exception(open(filepath).read()))
-        else:
-            suspend.resume()
-       
-        self._forgivingRemove(filepath)
+        remove(filepath)
         if needToAck:
             self._ack(filename)
-            
-        for suspendedidentifier, suspend in self._waiting:
-            if suspendedidentifier == identifier:
-                self._waiting.remove((suspendedidentifier, suspend))
-                suspend.resume()
-                break
-
-    def _ack(self, filename):
-        self._add(filename + ".ack", "")
-
-    def _error(self, filename, errormessage):
-        self._add(filename + ".error", errormessage)
-
-    def _isAckOrError(self, filename):
-        return filename.endswith('.ack') or filename.endswith('.error')
+        elif ackOrError:
+            for suspendedidentifier, suspend in self._waiting:
+                if suspendedidentifier == identifier:
+                    self._waiting.remove((suspendedidentifier, suspend))
+                    suspend.resume()
+                    break
 
     def add(self, identifier, filedata, **kwargs):
         filename = escapeFilename(identifier)
+        outFilePath = join(self._outDirectory, filename)
+        if hasattr(filedata, 'read'):
+            tmpFilePath = self._tempFileName()
+            link(filedata.name, tmpFilePath)
+        else:
+            tmpFilePath = self._writeTempFile(filedata)
         if self._asynchronous:
             suspend = Suspend()
-            if identifier in self._suspended:
-                while identifier in self._suspended:
-                    self._waiting.append((identifier, suspend))
-                    yield suspend
-                    suspend.getResult()
-            assert identifier not in self._suspended 
-            self._add(filename, filedata, **kwargs)
+            while isfile(outFilePath):
+                self._waiting.append((identifier, suspend))
+                yield suspend
+                suspend.getResult()
+            assert identifier not in self._suspended
             self._suspended[identifier] = suspend
+            self._moveOrDitch(tmpFilePath, outFilePath)
             yield suspend
             suspend.getResult()
         else:
-            self._add(filename, filedata, **kwargs)
+            self._moveOrDitch(tmpFilePath, outFilePath)
 
-    def _add(self, filename, filedata, **kwargs):
-        """Adds a file to the outDirectory. 
-           'filedata' can be one of:
-           * a file object
-           * a file-like object
-           * a string with data
-        """
-        outFilepath = join(self._outDirectory, filename)
-        self._purge(outFilepath)
-        tmpFilePath = join(self._tmpDirectory, filename)
-        
-        try:
-            if hasattr(filedata, 'read'):
-                link(filedata.name, tmpFilePath)
-            else:
-                with open(tmpFilePath, 'w') as tmpFile:
-                    tmpFile.write(filedata)
-            rename(tmpFilePath, outFilepath)
-        except:
-            self._forgivingRemove(tmpFilePath)
-            raise
-
-    def _purge(self, filepath):
-        for ext in ('', '.ack', '.error'):
-            if isfile(filepath + ext):
-                self._forgivingRemove(filepath + ext)
 
-    def _forgivingRemove(self, filepath):
+    def _isAckOrError(self, filename):
+        return filename.endswith('.ack') or filename.endswith('.error')
+
+    def _ack(self, filename):
+        self._atomicWrite(filename + ".ack", "")
+
+    def _error(self, filename, errormessage):
+        self._atomicWrite(filename + ".error", errormessage)
+
+    def _atomicWrite(self, name, data):
+        path = self._writeTempFile(data)
+        self._moveOrDitch(path, join(self._outDirectory, name))
+
+    def _writeTempFile(self, data):
+        tmpFilePath = self._tempFileName()
+        with open(tmpFilePath, 'w') as tmpFile:
+            tmpFile.write(data)
+        return tmpFilePath
+
+    def _tempFileName(self):
+        return join(self._tmpDirectory, str(randint(1, 2**48)))
+
+    def _moveOrDitch(self, src, dst):
         try:
-            remove(filepath)
-        except OSError, e:
-            if str(e) != "[Errno 2] No such file or directory: '%s'" % filepath:
-                raise
+            rename(src, dst)
+        finally:
+            if isfile(src):
+                remove(src)
+
+    def _impliesInputError(self, e):
+        # Input (Java) errors, like invalid RDF, must be ValueErrors.
+        return isinstance(e, ValueError) or \
+               (isinstance(e, IOError) and e.errno == 2)  # No such file or directory
+
 
 class File(object):
     def __init__(self, path):
@@ -223,4 +219,3 @@
         while x:
             yield x
             x = f.read(4096)
-
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_7/test/msgbox/msgboxtest.py version_7-cleanupMsgbox/test/msgbox/msgboxtest.py
--- version_7/test/msgbox/msgboxtest.py	2010-09-21 07:02:37.000000000 +0000
+++ version_7-cleanupMsgbox/test/msgbox/msgboxtest.py	2010-09-21 10:27:41.000000000 +0000
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 ## begin license ##
 #
 #    Meresco Components are components to build searchengines, repositories
@@ -168,7 +169,7 @@
         self.assertTrue(errorMessage.startswith("Traceback (most recent call last):"))
         self.assertTrue(errorMessage.endswith("ValueError\n"), errorMessage)
         self.assertTrue(self.msgbox._watcher in self.reactor._readers)
-    
+
     def testAck(self):
         self.createMsgbox(asynchronous=True)
         filename='repository:some:identifier:1.record'
@@ -197,7 +198,7 @@
         open(join(tmpDirectory, filename), 'w').close()
         self.createMsgbox()
         self.assertEquals(0, len(self.listfiles(self.msgbox._tmpDirectory)))
-   
+
     def testAddWithFilenameAndFiledata(self):
         self.createMsgbox()
         filename = "testfile"
@@ -233,6 +234,7 @@
         with open(join(self.outDirectory, outFiles[0]), 'r') as f:
             self.assertEquals(DATA, f.read())
 
+    # suspicious (old reality)!
     def testDuplicateReplacesOriginal(self):
         self.createMsgbox()
         filename = "testfile"
@@ -243,6 +245,7 @@
         self.assertEquals([filename], outFiles)
         self.assertEquals(data2, open(join(self.outDirectory, filename)).read())
 
+    # suspicious (old reality)!
     def testExistingAckReplaced(self):
         self.createMsgbox()
         filename = 'repository:some:identifier:1.record'
@@ -254,7 +257,7 @@
         self.assertFalse(isfile(join(self.inDirectory, filename)))
         self.assertTrue(isfile(join(self.outDirectory, filename + '.ack')))
         self.assertFalse(isfile(join(self.outDirectory, filename + '.error')))
-    
+
     def testNoFilesLeftBehindOnMoveError(self):
         self.createMsgbox()
         filename = "test"
@@ -267,14 +270,6 @@
         finally:
             chmod(self.outDirectory, S_IRUSR | S_IWUSR | S_IXUSR)
 
-    def testIgnoreFailedRemoveWhenNoExistsFromIn(self):
-        self.createMsgbox()
-        try:
-            self.msgbox.processFile("existed_but_being_replaced_with_newer_instance_by_other_process")
-        except Exception, e:
-            self.fail(e)
-        self.assertTrue(isfile(join(self.outDirectory, "existed_but_being_replaced_with_newer_instance_by_other_process.ack")))
-
     def testRaiseErrorWhenOtherFailureThanNotExists(self):
         self.createMsgbox()
         try:
@@ -282,12 +277,12 @@
             self.fail("Remove a directory should raise an error and not be ignored.")
         except OSError:
             pass
-    
+
     def testAddSynchronousIsEmptyGenerator(self):
         self.createMsgbox()
 
         result = self.msgbox.add('filename', 'data')
-        
+
         self.assertFalse(isfile(join(self.outDirectory, 'filename')))
         self.assertRaises(StopIteration, result.next)
         self.assertTrue(isfile(join(self.outDirectory, 'filename')))
@@ -314,7 +309,7 @@
         myreactor.returnValues['suspend'] = 'handle'
 
         result = self.msgbox.add('filename', 'data')
-        
+
         self.assertFalse(isfile(join(self.outDirectory, 'filename')))
         suspend = result.next()
         suspend(myreactor, lambda: None)
@@ -322,7 +317,7 @@
         self.assertTrue(isfile(join(self.outDirectory, 'filename')))
 
         self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
-       
+
         self.moveInRecord('filename.ack', '')
         self.assertTrue('filename' in self.msgbox._suspended)
         self.reactor.step()
@@ -338,11 +333,11 @@
         myreactor.returnValues['suspend'] = 'handle'
 
         result = self.msgbox.add('filename', 'data')
-        
+
         self.assertFalse(isfile(join(self.outDirectory, 'filename')))
         suspend = result.next()
         suspend(myreactor, lambda: None)
-        
+
         result2 = self.msgbox.add('filename', 'data2')
         suspend2 = result2.next()
         suspend2(myreactor, lambda: None)
@@ -350,7 +345,8 @@
         self.assertEquals('data', open(join(self.outDirectory, 'filename')).read())
 
         self.assertEquals(['suspend', 'suspend'], [m.name for m in myreactor.calledMethods])
-       
+
+        remove(join(self.outDirectory, 'filename'))
         self.moveInRecord('filename.ack', '')
         self.assertTrue('filename' in self.msgbox._suspended)
         self.assertTrue(1, len(self.msgbox._waiting))
@@ -363,7 +359,7 @@
         self.moveInRecord('filename.ack', '')
         self.reactor.step()
         self.assertFalse('filename' in self.msgbox._suspended)
-        
+
         self.assertEquals(['suspend', 'suspend'], [m.name for m in myreactor.calledMethods])
 
         self.assertRaises(StopIteration, result.next)
@@ -375,11 +371,11 @@
         myreactor.returnValues['suspend'] = 'handle'
 
         result = self.msgbox.add('filename', 'data')
-        
+
         self.assertFalse(isfile(join(self.outDirectory, 'filename')))
         suspend = result.next()
         suspend(myreactor, lambda: None)
-        
+
         result2 = self.msgbox.add('filename', 'data2')
         suspend2 = result2.next()
         suspend2(myreactor, lambda: None)
@@ -387,11 +383,12 @@
         result3 = self.msgbox.add('filename', 'data3')
         suspend3 = result3.next()
         suspend3(myreactor, lambda: None)
-        
+
         self.assertEquals('data', open(join(self.outDirectory, 'filename')).read())
 
         self.assertEquals(['suspend', 'suspend', 'suspend'], [m.name for m in myreactor.calledMethods])
-       
+
+        remove(join(self.outDirectory, 'filename'))
         self.moveInRecord('filename.ack', '')
         self.assertEquals(2, len(self.msgbox._waiting))
         self.reactor.step()
@@ -400,6 +397,7 @@
         self.assertEquals(1, len(self.msgbox._waiting))
         self.assertEquals('data2', open(join(self.outDirectory, 'filename')).read())
 
+        remove(join(self.outDirectory, 'filename'))
         self.moveInRecord('filename.ack', '')
         self.reactor.step()
         result3.next()
@@ -410,11 +408,11 @@
         self.moveInRecord('filename.ack', '')
         self.reactor.step()
         self.assertFalse('filename' in self.msgbox._suspended)
-        
+
         self.assertEquals(['suspend', 'suspend', 'suspend'], [m.name for m in myreactor.calledMethods])
         self.assertEquals([], self.msgbox._waiting)
         self.assertEquals({}, self.msgbox._suspended)
-        
+
         self.assertRaises(StopIteration, result.next)
         self.assertRaises(StopIteration, result2.next)
         self.assertRaises(StopIteration, result3.next)
@@ -425,7 +423,7 @@
         myreactor.returnValues['suspend'] = 'handle'
 
         result = self.msgbox.add('filename', 'data')
-        
+
         self.assertFalse(isfile(join(self.outDirectory, 'filename')))
         suspend = result.next()
         suspend(myreactor, lambda: None)
@@ -433,7 +431,7 @@
         self.assertTrue(isfile(join(self.outDirectory, 'filename')))
 
         self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
-       
+
         self.moveInRecord('filename.error', 'Stacktrace')
         self.reactor.step()
 
@@ -524,4 +522,4 @@
 
     def listfiles(self, directory):
         return [f for f in listdir(directory) if isfile(join(directory, f))]
-        
+
