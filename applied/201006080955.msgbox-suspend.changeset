Changeset created on Tue Jun  8 09:55:31 CEST 2010 by Seek You Too

Description: Msgbox uses weightless.Suspend in asynchronous mode.

    The Msgbox will use the suspend functionality introduced in Weightless
    0.4.11. In asynchronous mode the generator created by calling add(..)
    will suspend after writing the file to the outbox. The generator is 
    resumed when an ack or error for this file is found in the inbox.

Baseline version: meresco-components/workingsets/3.0-Edurep/version_2

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/deps.txt version_3/deps.txt
--- version_2/deps.txt	2010-06-04 10:31:53.000000000 +0200
+++ version_3/deps.txt	2010-06-08 09:54:56.000000000 +0200
@@ -1,4 +1,6 @@
 python-meresco-core-3.0-edurep (>= 1)
+python-weightless (>= 0.4.11)
+python-weightless (<< 0.5)
 python-cqlparser (>=1.5.2)
 python-cqlparser (<<1.6)
 python-storage (>=5.1.7)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/meresco/components/msgbox/msgbox.py version_3/meresco/components/msgbox/msgbox.py
--- version_2/meresco/components/msgbox/msgbox.py	2010-06-04 10:31:53.000000000 +0200
+++ version_3/meresco/components/msgbox/msgbox.py	2010-06-08 09:54:56.000000000 +0200
@@ -24,10 +24,6 @@
 ## end license ##
 
 from __future__ import with_statement
-from meresco.core import Observable
-
-from cq2utils import DirectoryWatcher
-from lxml.etree import parse
 
 from os.path import join, isdir, isfile, basename, abspath
 from os import rename, listdir, remove, makedirs, link
@@ -35,6 +31,11 @@
 from traceback import format_exc
 from sys import stderr
 
+from meresco.core import Observable
+from cq2utils import DirectoryWatcher
+from lxml.etree import parse
+from weightless import Suspend
+
 class Msgbox(Observable):
     """
     Msgbox provides a file based messaging protocol: it receives incoming files and 
@@ -84,8 +85,10 @@
         if isdir(self._tmpDirectory):
             rmtree(self._tmpDirectory)
         makedirs(self._tmpDirectory)
+        self._synchronous = not asynchronous
         self._asynchronous = asynchronous
         self._reactor = reactor
+        self._suspended = {}
 
     def observer_init(self):
         self.processInDirectory()
@@ -102,21 +105,31 @@
 
     def processFile(self, filename):
         filepath = join(self._inDirectory, filename)
-        try:
-            self.do.add(filename=filename, filedata=File(filepath))
-            if not self._asynchronous and not self._isAckOrError(filename):
-                self._ack(filename)
-        except Exception, e:
-            self._logError(format_exc())
-            if not self._isAckOrError(filename):
+        if not self._isAckOrError(filename):
+            try:
+                self.do.add(filename=filename, filedata=File(filepath))
+                if self._synchronous:
+                    self._ack(filename)
+            except Exception:
+                self._logError(format_exc())
                 self._error(filename, format_exc())
+        else:
+            try:
+                self.do.add(filename=filename, filedata=File(filepath))
+            except Exception:
+                self._logError(format_exc())
+            if self._asynchronous:
+                strippedFilename, result = filename.rsplit('.',1)
+                suspend = self._suspended[strippedFilename]
+                message = '' if result == 'ack' else open(filepath).read()
+                suspend.resumeWriter(state=(result, message))
         self._forgivingRemove(filepath)
 
     def _ack(self, filename):
-        self.add(filename + ".ack", "")
+        self._add(filename + ".ack", "")
 
     def _error(self, filename, errormessage):
-        self.add(filename + ".error", errormessage)
+        self._add(filename + ".error", errormessage)
 
     def _isAckOrError(self, filename):
         return filename.endswith('.ack') or filename.endswith('.error')
@@ -126,6 +139,17 @@
         stderr.flush()
 
     def add(self, filename, filedata, **kwargs):
+        self._add(filename, filedata, **kwargs)
+        if self._asynchronous:
+            suspend = Suspend()
+            self._suspended[filename] = suspend
+            yield suspend
+            del self._suspended[filename]
+            result, message = suspend.state
+            if result == 'error':
+                raise Exception(message)
+
+    def _add(self, filename, filedata, **kwargs):
         """Adds a file to the outDirectory. 
            'filedata' can be one of:
            * a file object
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/test/msgbox/msgboxtest.py version_3/test/msgbox/msgboxtest.py
--- version_2/test/msgbox/msgboxtest.py	2010-06-04 10:31:53.000000000 +0200
+++ version_3/test/msgbox/msgboxtest.py	2010-06-08 09:54:56.000000000 +0200
@@ -137,7 +137,7 @@
 
     def testCreateAsynchronousMsgbox(self):
         self.createMsgbox(asynchronous=True)
-        self.assertTrue(self.msgbox._asynchronous)
+        self.assertFalse(self.msgbox._synchronous)
 
     def testProcessFileInAsynchronousMsgbox(self):
         self.createMsgbox(asynchronous=True)
@@ -202,7 +202,7 @@
         self.createMsgbox()
         filename = "testfile"
         filedata = DATA
-        self.msgbox.add(filename, filedata)
+        list(self.msgbox.add(filename, filedata))
         outFiles = self.listfiles(self.outDirectory)
         tmpFiles = self.listfiles(self.msgbox._tmpDirectory)
         self.assertEquals(1, len(outFiles))
@@ -216,7 +216,7 @@
         filename = "testfile"
         filepath = join(self.tempdir, filename)
         open(filepath, "w").write(DATA)
-        self.msgbox.add(filename, File(filepath), ignoredKwarg="e.g. useful to have parsed lxmlNode included in combination with XmlXPath filtering")
+        list(self.msgbox.add(filename, File(filepath), ignoredKwarg="e.g. useful to have parsed lxmlNode included in combination with XmlXPath filtering"))
         outFiles = self.listfiles(self.outDirectory)
         self.assertEquals(filename, outFiles[0])
         with open(join(self.outDirectory, outFiles[0]), 'r') as f:
@@ -227,7 +227,7 @@
         filename = "testfile"
         filepath = join(self.tempdir, filename)
         open(filepath, "w").write(DATA)
-        self.msgbox.add(filename, open(filepath), ignoredKwarg="e.g. useful to have parsed lxmlNode included in combination with XmlXPath filtering")
+        list(self.msgbox.add(filename, open(filepath), ignoredKwarg="e.g. useful to have parsed lxmlNode included in combination with XmlXPath filtering"))
         outFiles = self.listfiles(self.outDirectory)
         self.assertEquals(basename(filepath), outFiles[0])
         with open(join(self.outDirectory, outFiles[0]), 'r') as f:
@@ -236,9 +236,9 @@
     def testDuplicateReplacesOriginal(self):
         self.createMsgbox()
         filename = "testfile"
-        self.msgbox.add(filename, DATA)
+        list(self.msgbox.add(filename, DATA))
         data2 = "<a>something</a>"
-        self.msgbox.add(filename, data2)
+        list(self.msgbox.add(filename, data2))
         outFiles = self.listfiles(self.outDirectory)
         self.assertEquals([filename], outFiles)
         self.assertEquals(data2, open(join(self.outDirectory, filename)).read())
@@ -261,7 +261,7 @@
         filedata = DATA
         try:
             chmod(self.outDirectory, S_IRUSR | S_IXUSR)
-            self.assertRaises(OSError, lambda: self.msgbox.add(filename, filedata))
+            self.assertRaises(OSError, lambda: list(self.msgbox.add(filename, filedata)))
             tmpFiles = self.listfiles(self.msgbox._tmpDirectory)
             self.assertEquals(0, len(tmpFiles))
         finally:
@@ -274,7 +274,7 @@
         msgbox2.observer_init()
         filename = "test"
         filedata = DATA
-        self.msgbox.add(filename, filedata) 
+        list(self.msgbox.add(filename, filedata))
         reactor2.step()
         self.assertEquals(['%s.ack' % filename], self.listfiles(self.inDirectory))
         self.assertEquals(0, len(self.observer.calledMethods))
@@ -318,6 +318,68 @@
             self.fail("Remove a directory should raise an error and not being ignored.")
         except OSError:
             pass
+    
+    def testAddSynchronousIsEmptyGenerator(self):
+        self.createMsgbox()
+
+        result = self.msgbox.add('filename', 'data')
+        
+        self.assertFalse(isfile(join(self.outDirectory, 'filename')))
+        self.assertRaises(StopIteration, result.next)
+        self.assertTrue(isfile(join(self.outDirectory, 'filename')))
+
+    def testAddAsynchronousYieldsSuspendAndReceivesAck(self):
+        self.createMsgbox(asynchronous=True)
+        myreactor = CallTrace('reactor')
+        myreactor.returnValues['suspend'] = 'handle'
+
+        result = self.msgbox.add('filename', 'data')
+        
+        self.assertFalse(isfile(join(self.outDirectory, 'filename')))
+        suspend = result.next()
+        suspend(myreactor)
+
+        self.assertTrue(isfile(join(self.outDirectory, 'filename')))
+
+        self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
+       
+        self.moveInRecord('filename.ack', '')
+        self.reactor.step()
+
+        self.assertEquals(['suspend', 'resumeWriter'], [m.name for m in myreactor.calledMethods])
+
+        self.assertRaises(StopIteration, result.next)
+
+    def testAddAsynchronousYieldsSuspendAndReceivesError(self):
+        self.createMsgbox(asynchronous=True)
+        myreactor = CallTrace('reactor')
+        myreactor.returnValues['suspend'] = 'handle'
+
+        result = self.msgbox.add('filename', 'data')
+        
+        self.assertFalse(isfile(join(self.outDirectory, 'filename')))
+        suspend = result.next()
+        suspend(myreactor)
+
+        self.assertTrue(isfile(join(self.outDirectory, 'filename')))
+
+        self.assertEquals(['suspend'], [m.name for m in myreactor.calledMethods])
+       
+        self.moveInRecord('filename.error', 'Stacktrace')
+        self.reactor.step()
+
+        self.assertEquals(['suspend', 'resumeWriter'], [m.name for m in myreactor.calledMethods])
+
+        try:
+            result.next()
+            self.fail('Expected an exception.')
+        except Exception, e:
+            self.assertEquals('Stacktrace', str(e))
+        self.assertRaises(StopIteration, result.next)
+
+
+
+    # helper methods
 
     def createMsgbox(self, asynchronous=False):
         self.msgbox = Msgbox(self.reactor, inDirectory=self.inDirectory, outDirectory=self.outDirectory, asynchronous=asynchronous)
