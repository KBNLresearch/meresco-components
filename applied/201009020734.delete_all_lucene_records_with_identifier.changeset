Changeset created on Thu Sep  2 07:34:01 UTC 2010 by Seek You Too

Description: _luceneDelete deletes all Lucene documents with given identifier instead of just a single one

    Recognizing that - as the consequence of an historical bug - there may be more Lucene records with the same identifier, _luceneDelete will now delete all of them (instead of giving up on deleting anything alltogether). 

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-components/workingsets/3.3-CQ2/version_0

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/components/facetindex/lucene.py version_0-forgiving_delete_multiple_occurences/meresco/components/facetindex/lucene.py
--- version_0/meresco/components/facetindex/lucene.py	2010-09-01 12:50:37.000000000 +0000
+++ version_0-forgiving_delete_multiple_occurences/meresco/components/facetindex/lucene.py	2010-09-01 14:49:50.000000000 +0000
@@ -141,12 +141,6 @@
         results = islice(hits, start, stop)
         return nrOfResults, [hit.getDocument().get(IDFIELD) for hit in results]
 
-    def _luceneIdForIdentifier(self, identifier):
-        hits = self._searcher.search(TermQuery(Term(IDFIELD, identifier)) % Query)
-        if hits.length() == 1:
-            return hits.id(0)
-        return None
-
     def getIndexReader(self):
         return self._reader
 
@@ -162,13 +156,17 @@
         except StopIteration:
             return None
 
+    def _luceneIdsForIdentifier(self, identifier):
+        hits = self._searcher.search(TermQuery(Term(IDFIELD, identifier)) % Query)
+        return (hit.getId() for hit in iterJ(hits))
+
     def _luceneDelete(self, identifier):
         docId = self._docIdFromLastAddCommandFor(identifier)
-        if docId is None:
-            prevTxLuceneId = self._luceneIdForIdentifier(identifier)
-            if prevTxLuceneId != None:
-                docId = self._lucene2docId[prevTxLuceneId]
         if docId != None:
+            docIds = [docId]
+        else:
+            docIds = (self._lucene2docId[luceneid] for luceneid in self._luceneIdsForIdentifier(identifier))
+        for docId in docIds:
             deleted = self._currentTracker.deleteDocId(docId)
             if deleted:
                 self._commandQueue.append(FunctionCommand(self._delete, identifier=identifier))
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/facetindex/lucenetest.py version_0-forgiving_delete_multiple_occurences/test/facetindex/lucenetest.py
--- version_0/test/facetindex/lucenetest.py	2010-09-01 12:50:37.000000000 +0000
+++ version_0-forgiving_delete_multiple_occurences/test/facetindex/lucenetest.py	2010-09-01 14:24:19.000000000 +0000
@@ -1,5 +1,4 @@
 # -*- coding: utf-8 -*-
-# -*- encoding: utf-8 -*-
 ## begin license ##
 #
 #    Meresco Components are components to build searchengines, repositories
@@ -530,5 +527,25 @@
 -3
 +4
 =
-""" % self.tempdir, open(logfilename).read()) 
+""" % self.tempdir, open(logfilename).read())
 
+    def testDeleteMultipleOccurrencesOfIdentifier(self):
+        document = Document('identifier')
+        document.addIndexedField('field', 'value')
+
+        document.addToIndexWith(self._luceneIndex._writer)
+        document.addToIndexWith(self._luceneIndex._writer)  # should not happen in practice, but has been seen to happen as the result of historical bug
+        self._luceneIndex._writer.optimize()
+        self._luceneIndex.close()
+
+        luceneIndex = LuceneIndex(directoryName=self.tempdir)
+
+        total, hits = luceneIndex.executeQuery(MatchAllDocsQuery())
+        self.assertEquals(2, total)
+
+        luceneIndex.delete('identifier')
+        luceneIndex.commit()
+
+        total, hits = luceneIndex.executeQuery(MatchAllDocsQuery())
+        self.assertEquals(0, total)
+        self.assertEquals(0, luceneIndex._currentTracker.nrOfDocs())
