Changeset created on Tue Nov 08 10:04:23 UTC 2011 by Seecr (Seek You Too B.V.)

Description: Taking care of unexpected 'tail' attribute on xpath result Element.

    libxml2/lxml deliberately keep text nodes (usually whitespace) after an element node
    with that element node. In xslt processing this sometimes causes aborts.
    By getting rid of this tail (that was unwanted in the first place) these aborts
    can be prevented. This is achieved by calling the new utility function lxmlElementUntail
    from the XmlXPath and Venturi components.

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-components/workingsets/3.4.20-Natag/version_0

diff --unidirectional-new-file --recursive --unified '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' version_0/meresco/components/venturi.py version_2/meresco/components/venturi.py
--- version_0/meresco/components/venturi.py	2011-11-07 14:14:50.000000000 +0100
+++ version_2/meresco/components/venturi.py	2011-11-08 11:02:55.000000000 +0100
@@ -27,10 +27,14 @@
 #
 ## end license ##
 
-from meresco.core import Observable
 from lxml.etree import _Element, ElementTree, parse, XMLParser
 from StringIO import StringIO
 
+from meresco.core import Observable
+
+from meresco.components.xmlxpath import lxmlElementUntail
+
+
 class Venturi(Observable):
     def __init__(self, should=[], could=[], namespaceMap={}):
         Observable.__init__(self)
@@ -54,26 +58,25 @@
             if part != None:
                 yield self.all.add(identifier=identifier, partname=couldPartname, lxmlNode=part)
 
+    def delete(self, identifier):
+        self.ctx.tx.locals['id'] = identifier
+        yield self.asyncdo.delete(identifier=identifier)
+
     def _findPart(self, identifier, partname, lxmlNode, partXPath):
         matches = lxmlNode.xpath(partXPath, namespaces=self._namespaceMap)
         if len(matches) > 1:
             raise VenturiException("XPath '%s' should return atmost one result." % partXPath)
         if len(matches) == 1:
-            return self._convert(matches[0])
-        else:
-            if self.any.isAvailable(identifier, partname) == (True, True):
-                return parse(self.any.getStream(identifier, partname))
-            else:
-                return None
-
-    def _convert(self, anObject):
-        if type(anObject) == _Element:
-            return ElementTree(anObject)
-        return parse(StringIO(anObject))
+            return self._nodeOrText2ElementTree(matches[0])
+        if self.any.isAvailable(identifier, partname) == (True, True):
+            return parse(self.any.getStream(identifier, partname))
+        return None
+
+    def _nodeOrText2ElementTree(self, nodeOrText):
+        if type(nodeOrText) == _Element:
+            return ElementTree(lxmlElementUntail(nodeOrText))
+        return parse(StringIO(nodeOrText))
 
-    def delete(self, identifier):
-        self.ctx.tx.locals['id'] = identifier
-        yield self.asyncdo.delete(identifier=identifier)
 
 class VenturiException(Exception):
     pass
diff --unidirectional-new-file --recursive --unified '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' version_0/meresco/components/xmlxpath.py version_2/meresco/components/xmlxpath.py
--- version_0/meresco/components/xmlxpath.py	2011-11-07 14:14:50.000000000 +0100
+++ version_2/meresco/components/xmlxpath.py	2011-11-08 11:02:55.000000000 +0100
@@ -27,6 +27,7 @@
 #
 ## end license ##
 
+from copy import copy
 from meresco.core import Observable
 from lxml.etree import ElementTree, _ElementTree as ElementTreeType, parse
 from StringIO import StringIO
@@ -79,4 +80,15 @@
                 if type(element) in [_ElementStringResult, _ElementUnicodeResult]:
                     yield element
                 else:
-                    yield ElementTree(element)
+                    yield ElementTree(lxmlElementUntail(element))
+
+
+def lxmlElementUntail(element):
+    """Utility that works around a problem in lxml.
+Should be applied to Elements that are taken out of one ElementTree to be wrapped in a new ElementTree and fed to an XSLT transformation (which would otherwise sometimes segfault)."""
+
+    if not element.tail is None:
+        element = copy(element)
+        element.tail = None
+    return element
+
diff --unidirectional-new-file --recursive --unified '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' version_0/test/venturitest.py version_2/test/venturitest.py
--- version_0/test/venturitest.py	2011-11-07 14:14:49.000000000 +0100
+++ version_2/test/venturitest.py	2011-11-08 11:02:53.000000000 +0100
@@ -1,3 +1,4 @@
+# -*- coding=utf-8 -*-
 ## begin license ##
 #
 #    Meresco Components are components to build searchengines, repositories
@@ -194,3 +195,26 @@
         v.addDocumentPart(identifier='x', partname='y', lxmlNode='dummy')
         self.assertEquals([{'args': (), 'kwargs': dict(identifier='x', partname='y', lxmlNode='dummy')}], addInvocations)
 
+    def testNoLxmlTailOnPart(self):
+        inputEvent = fromstring("""<document><part name="partone">&lt;some&gt;message&lt;/some&gt;\n\n\n\n</part><part name="parttwo"><second>message</second>\n\n\n\n</part></document>""")
+        interceptor = CallTrace('Interceptor')
+        v = createVenturiHelix([('partone', '/document/part[@name="partone"]/text()'), ('parttwo', '/document/part/second')], [], interceptor)
+        list(v.all.add('identifier', 'document', inputEvent))
+
+        self.assertEquals('<some>message</some>', tostring(interceptor.calledMethods[1].kwargs['lxmlNode']))
+        secondXml = interceptor.calledMethods[2].kwargs['lxmlNode']
+        self.assertEquals('<second>message</second>', tostring(secondXml))
+
+    def testPartsWithUnicodeChars(self):
+        inputEvent = fromstring("""<document><part name="partone">&lt;some&gt;t€xt&lt;/some&gt;\n\n\n\n</part><part name="parttwo"><second>t€xt</second>\n\n\n\n</part></document>""")
+        interceptor = CallTrace('Interceptor')
+        v = createVenturiHelix([('partone', '/document/part[@name="partone"]/text()'), ('parttwo', '/document/part/second')], [], interceptor)
+        list(v.all.add('identifier', 'document', inputEvent))
+
+        firstXml = interceptor.calledMethods[1].kwargs['lxmlNode']
+        self.assertEquals('<some>t&#8364;xt</some>', tostring(firstXml))
+        self.assertEquals('t€xt', firstXml.getroot().text)
+        secondXml = interceptor.calledMethods[2].kwargs['lxmlNode']
+        self.assertEquals('<second>t&#8364;xt</second>', tostring(secondXml))
+        self.assertEquals('t€xt', secondXml.getroot().text)
+
diff --unidirectional-new-file --recursive --unified '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' version_0/test/xmlxpathtest.py version_2/test/xmlxpathtest.py
--- version_0/test/xmlxpathtest.py	2011-11-07 14:14:49.000000000 +0100
+++ version_2/test/xmlxpathtest.py	2011-11-08 11:02:53.000000000 +0100
@@ -32,16 +32,15 @@
 from meresco.core import Observable, be
 
 from meresco.components import XmlXPath, XmlParseLxml
+from meresco.components.xmlxpath import lxmlElementUntail
 from lxml.etree import parse, ElementTree, _ElementTree as ElementTreeType, tostring
 from StringIO import StringIO
 import sys
 
 
-
 class XmlXPathTest(CQ2TestCase):
 
     def createXmlXPath(self, xpathList, nsMap):
-        self.observable = Observable()
         self.observer = CallTrace('observer',ignoredAttributes=['start'] )
         self.observable = be(
             (Observable(),
@@ -73,7 +72,8 @@
     def testSimpleXPath(self):
         self.createXmlXPath(['/root/path'], {})
 
-        self.observable.do.test('een tekst', data='<root><path><to>me</to></path></root>')
+        xml = '<root><path><to>me</to></path>\n</root>'
+        self.observable.do.test('een tekst', data=xml)
 
         self.assertEquals(1, len(self.observer.calledMethods))
         method = self.observer.calledMethods[0]
@@ -81,6 +81,7 @@
         self.assertEquals(1, len(method.args))
         self.assertEquals('een tekst', method.args[0])
         self.assertEqualsWS('<path><to>me</to></path>', tostring(method.kwargs['lxmlNode']))
+        self.assertEquals('<path><to>me</to></path>', tostring(method.kwargs['lxmlNode']))
 
     def testSimpleXPathWithUnicodeChars(self):
         self.createXmlXPath(['/root/text()'], {})
@@ -165,7 +166,7 @@
         except AssertionError, e:
             self.assertEquals('Can only handle one ElementTree in argument list.', str(e))
 
-    def testDoNotChangesArgs(self):
+    def testDoNotChangeArgs(self):
         xmlXPath = XmlXPath(['/a'])
         arg = parse(StringIO('<a>a</a>'))
         xmlXPath.unknown('message', arg)
@@ -239,3 +240,54 @@
         result = observer.calledMethods[0].kwargs
         self.assertEquals({'lxmlNode': 'some text & some <entities>'}, result)
 
+    def testTailTakeCareOfWithoutAffectingOriginal(self):
+        observer = CallTrace('observer')
+        observable = be(
+            (Observable(),
+                (XmlXPath(
+                        ['/myns:root/myns:path'],
+                        {'myns': 'http://myns.org/'}
+                    ),
+                    (observer, ),
+                )
+            )
+        )
+
+        XML = """\
+<root xmlns:myns="http://myns.org/" xmlns="http://myns.org/">
+    <myns:path>
+        <to>me</to>
+    </myns:path>\n
+</root>"""
+
+        lxmlNode = parse(StringIO(XML))
+        self.assertEquals(XML, tostring(lxmlNode))
+        list(observable.all.test('een tekst', lxmlNode=lxmlNode))
+
+        self.assertEquals(1, len(observer.calledMethods))
+        method = observer.calledMethods[0]
+        self.assertEquals('test', method.name)
+        self.assertEqualsWS('<myns:path xmlns:myns="http://myns.org/" xmlns="http://myns.org/"><to>me</to></myns:path>', tostring(method.kwargs['lxmlNode']))
+        self.assertEquals("""\
+<myns:path xmlns:myns="http://myns.org/" xmlns="http://myns.org/">
+        <to>me</to>
+    </myns:path>""", tostring(method.kwargs['lxmlNode']))
+
+        self.assertEquals(XML, tostring(lxmlNode))
+
+
+    def testLxmlElementUntail(self):
+        lxmlNode = parse(StringIO('<myns:root xmlns:myns="http://myns.org/" xmlns="http://myns.org/"><a>b</a></myns:root>'))
+        element = lxmlNode.xpath('/myns:root/myns:a', namespaces={'myns': 'http://myns.org/'})[0]
+        self.assertEquals(None, element.tail)
+        newElement = lxmlElementUntail(element)
+        self.assertTrue(newElement is element)
+
+        lxmlNode = parse(StringIO('<myns:root xmlns:myns="http://myns.org/" xmlns="http://myns.org/"><a><b>c</b>\n\n</a>\n\n\n\n</myns:root>'))
+        element = lxmlNode.xpath('/myns:root/myns:a', namespaces={'myns': 'http://myns.org/'})[0]
+        self.assertEquals('\n\n\n\n', element.tail)
+        newElement = lxmlElementUntail(element)
+        self.assertFalse(newElement is element)
+        self.assertEquals(None, newElement.tail)
+        self.assertEquals('<a xmlns="http://myns.org/"><b>c</b>\n\n</a>', tostring(newElement))
+
